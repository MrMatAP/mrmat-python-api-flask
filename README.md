# MrMat :: Python :: API :: Flask

[![Build](https://github.com/MrMatOrg/mrmat-python-api-flask/actions/workflows/build.yml/badge.svg)](https://github.com/MrMatOrg/mrmat-python-api-flask/actions/workflows/build.yml)

Boilerplate (and playground) for a code-first Python Flask API, with all the bells and whistles we've come to expect:

* Pluggable APIs and multiple API versions
* Database schema migration
* API body serialisation
* OIDC Authentication
* Healthz API
* Implementation of a generic resource API, showcasing how a service owner would manage slices of a wider offering
* No TLS because this is intended to run behind a reverse proxy
* Project auto-versioning

## How to build this

We use the [PEP517 build mechanism](https://www.python.org/dev/peps/pep-0517/) and build a wheel as follows:

```bash
$ pip install -r requirements.txt        # Manually install dependencies (see note in requirements.txt!)
$ export PYTHONPATH=`pwd`                # In order to find the build-time ci module
$ export MRMAT_VERSION=1.0.27            # Optional: To influence the version. Normally calculated and set by CI
$ python -m build -n --wheel             # Use -n in an interactive, virtual environment
... lots of output omitted
$ ls dist/
mrmat_python_api_flask-1.0.27.dev0-py3-none-any.whl

# Optional: Build a container image

$ docker build -t mrmat-python-api-flask:${MRMAT_VERSION} -f var/docker/Dockerfile .

# Optional: Install the package into your local environment

$ pip install --force-reinstall ./dist/mrmat_python_api_flask-1.0.27.dev0-py3-none-any.whl
```

```powershell
PS> pip install -r requirements.txt     # Manually install dependencies (see note in requirements.txt!)
PS> $Env:PYTHONPATH=(pwd)               # In order to find the build-time ci module
PS> $Env:MRMAT_VERSION = "1.0.27"       # Optional: To influence the version. Normally calculated and set by CI
PS> python -m build -n --wheel          # Use -n in an interactive, virtual environment
PS> ls dist/
Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----                                                                                                                                                                                                                                                                 
-a----        26/12/2021     11:24          33513 mrmat_python_api_flask-1.0.27-py3-none-any.whl

# Optional: Build a container image

$ docker build -t mrmat-python-api-flask:$Env:MRMAT_VERSION -f var/docker/Dockerfile .

# Optional: Install the package into your local environment

PS> pip install --force-reinstall ./dist/mrmat_python_api_flask-1.0.27.dev0-py3-none-any.whl
```

The project version is autogenerated based on MAJOR, MINOR and MICRO version numbers. MAJOR and MINOR are hardcoded
numbers in the CI configuration (currently GitHub Actions, see `.github/workflows/build.yml`). The MICRO number is
taken from the unique pipeline run injected by GitHub as `GITHUB_RUN_NUMBER`. This makes sure that we produce a unique
project version for every build and especially for a release.

The CI pipeline knows it's a release when it builds as part of a push to the main branch, which is technically meant
to be a protected branch that can only be modified via a pull request. `MRMAT_VERSION` is therefore set to a
concatenation of `${MAJOR}.${MINOR}.${GITHUB_RUN_NUMBER}` for a release artefact. For any other CI build, the calculated
version will be `${MAJOR}.${MINOR}.${GITHUB_RUN_NUMBER}.dev0`.

The calculated `MRMAT_VERSION` is picked up by the special build-time only Python module `ci`, which is specifically
excluded from becoming part of the final artefact. See how the `ci` module is used by the build system in `setup.cfg`.

If you are building locally, then your version will **always** be `0.0.0.dev0` (unless you explicitly set the
`MRMAT_VERSION` environment variable to something different).

## How to run this

You have the choice of running this 

* as a Flask app straight out of the project directory
* as a CLI app
* as a WSGI app 
* as a container image

### To run as a Flask app

You can, of course, run this as a Flask app straight from the project directory:

```shell
$ cd src/python
$ FLASK_APP=mrmat_python_api_flask flask run
 * Serving Flask app 'mrmat_python_api_flask' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
[12/26/21 13:06:45] INFO     INFO:mrmat_python_api_flask:Using existing instance path at
                             /home/imfeldma/projects/mrmat-python-api-flask/instance
[12/26/21 13:06:45] WARNING  WARNING:mrmat_python_api_flask:Running without any authentication/authorisation
[12/26/21 13:06:45] INFO     INFO:werkzeug: * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

```powershell
$ $Env:FLASK_APP=mrmat_python_api_flask
$ flask run
 * Serving Flask app 'mrmat_python_api_flask' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
[12/26/21 13:00:57] INFO     INFO:mrmat_python_api_flask:Using existing instance path at C:\Users\imfeldma\Projects\mrmat-python-api-flask\instance
[12/26/21 13:00:57] WARNING  WARNING:mrmat_python_api_flask:Running without any authentication/authorisation
[12/26/21 13:00:57] INFO     INFO:werkzeug: * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
```

### To run as a CLI app

A simple CLI app is provided for your convenience once you have installed the wheel:

```shell
usage: mrmat-python-api-flask [-h] [-d] [--host HOST] [--port PORT] [--instance-path INSTANCE_PATH] [--dsn DSN] [--oidc-secrets OIDC_SECRETS]

mrmat-python-api-flask - 1.0.27

options:
  -h, --help            show this help message and exit
  -d, --debug           Debug
  --host HOST           Host interface to bind to
  --port PORT           Port to bind to
  --instance-path INSTANCE_PATH
                        Fully qualified path to instance directory
  --dsn DSN             Database DSN
  --oidc-secrets OIDC_SECRETS
                        Path to file containing OIDC registration
```

```shell
$ mrmat-python-api-flask 
[2021-06-06 15:30:18,005] INFO: Using instance path at /opt/dyn/python/mrmat-python-api-flask/var/mrmat_python_api_flask-instance
[2021-06-06 15:30:18,005] WARNING: Running without any authentication/authorisation
 * Serving Flask app "mrmat_python_api_flask" (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
INFO  [werkzeug]  * Running on http://localhost:8080/ (Press CTRL+C to quit)

<Ctrl-C>
```

>**IMPORTANT**: 
> If you run on Windows, the default port 8080 is considered privileged. Use the `--port` option to override this
> to 8090, for example.

The instance directory defaults to `var/instance/` but you can override that to be a fully qualified path via the 
`--instance-path` option. Any database supported by SQLAlchemy and for which a driver is installed in the local
environment can be provided via the `--dsn` option. The default database is a SQLite instance within the instance 
directory.

### To run as a WSGI app

```
$ flask db upgrade
$ gunicorn --workers 2 'mrmat_python_api_flask:create_app()'
```

### To run as a container

To run as a container, first build a wheel as explained above, then build a container image:

```
$ docker build -t mrmat-python-api-flask:0.0.1 -f var/docker/Dockerfile .
...
$ docker run --rm mrmat-python-api-flask:0.0.1
```

>You may be tempted by Alpine, but most of the Python wheels do not work for it. Go for slim-buster instead

## Configuration

You can provide configuration in a JSON file pointed to by the APP_CONFIG environment variable, which defaults to
`~/etc/mrmat-python-api-flask.json`. The configuration file can contain anything the app picks up (see
`mrmat_python_api_flask/__init__.py`) but should typically contain the following three items:

```json
{
  "SECRET_KEY": "4tbBVKc6gk1eZIhnt-9Igg",
  "OIDC_CLIENT_SECRETS": "/path/to/oidc-secrets.json",
  "SQLALCHEMY_DATABASE_URI": "postgresql://mpaf:secret@localhost:5432/localdb"
}
```

* SECRET_KEY secures the session cookie. If not specified, this will be randomised at every start which will
  invalidate any existing session. While this does not make a difference when running without OIDC authentication,
  it is strongly recommended to persist the session key. Create one using `import secrets; secrets.token_urlsafe(16)`
* OIDC_CLIENT_SECRETS configures OIDC and should point to a separate configuration file. See the OIDC section for
  information about its contents
* SQLALCHEMY_DATABASE_URI configures the database to use. The default SQLite is at most appropriate for quick testing.


## How to use this

Once started, you can curl towards the APIs mounted at various places. See the invocations of `app.register_blueprint`
within `mrmat_python_api_flask/__.init__.py` to find out where. 

>Note that omitting the last slash will cause a redirect that you can follow using curls -L option. We can probably
>get rid of that by using a more clever versioning scheme that doesn't make the root resource listen on / (e.g. `/greeting`).

## How to test this

Unit tests are within the `tests` directory. You can use the built-in Pycharm test configuration or do it on the CLI.

```
$ pytest
```

You will find that the test suite operates in two modes. Completely on its own without local infrastructure and
with local infrastructure present. When no local infrastructure to test with is present, tests that require
OIDC are skipped. If local infrastructure is present then PostgreSQL and Keycloak are used for full integration testing.

Whether local infrastructure is present is discovered via the `TI_CONFIG` environment variable which is expected to 
point to a JSON configuration file of the following structure:

```json
{
	"pg": {
		"admin_dsn": "postgresql://postgres:secret@localhost:5432/localdb"
	},
	"keycloak": {
		"admin_url": "http://localhost:8080/auth/",
		"admin_user": "admin",
		"admin_password": "secret",
		"admin_realm": "master"
	}
}
```

Note how the config file contains credentials for administrative access. The test suite will establish roles, users,
client_ids and schemata for testing using these credentials and tear them down if so desired. See the classes in
`tests/conftest.py`.

## Database Setup

A simple SQLite database is used by default for persistence needs. The project has been tested with PostgreSQL, but in 
theory you can use any database supported by SQLAlchemy. It is a matter of (my personal) preference to have a single 
database with dedicated schemas per role in PostgreSQL, like so:

```postgresql
CREATE ROLE mpaf ENCRYPTED PASSWORD 'secret' LOGIN;
CREATE SCHEMA mpaf;
ALTER SCHEMA mpaf OWNER TO mpaf;
ALTER ROLE mpaf SET SEARCH_PATH TO mpaf;
```

With a database set up this way, you can then use the `--dsn` CLI parameter to configure the application so it connects
to real PostgreSQL database rather than the built-in, small-scale SQLite. **Do note that a database migration is
performed before the service is started.**

```shell
$ mrmat-python-api-flask --dsn postgresql://mpaf:secret@dbserver:5432/dbname
[12/26/21 13:19:40] INFO     INFO:mrmat_python_api_flask:Using existing instance path at /home/imfeldma/projects/mrmat-python-api-flask\instance
[12/26/21 13:19:40] WARNING  WARNING:mrmat_python_api_flask:Running without any authentication/authorisation
INFO  [alembic.runtime.migration] Context impl PostgresqlImpl.
INFO  [alembic.runtime.migration] Will assume transactional DDL.
INFO  [alembic.runtime.migration] Running upgrade  -> 1bea80b612cc, initial
 * Serving Flask app 'mrmat_python_api_flask' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
INFO  [werkzeug]  * Running on http://localhost:8090/ (Press CTRL+C to quit)
```

## OIDC Setup

No authentication/authorisation is enforced by default. Token-based authentication via OpenID Connect (OIDC) can be
enforced by configuring connectivity to such extra central infrastructure. For this to happen, you must register the
app in your OIDC IdP and create an OIDC secrets configuration file (json) of the following structure, which you
subsequently point to using the `--oidc-secrets` option of the CLI or the `OIDC_CLIENT_SECRETS` key of the configuration
file pointed to by the `APP_CONFIG` environment variable.

```json
{
  "web": {
    "client_id": "CLIENT_ID",
    "client_secret": "CLIENT_SECRET",
    "auth_uri": "AUTHORIZATION_ENDPOINT",
    "token_uri": "TOKEN_ENDPOINT",
    "userinfo_uri": "USERINFO_ENDPOINT",
    "token_introspection_uri": "INTROSPECTION_ENDPOINT",
    "issuer": "ISSUER",
    "redirect_uris": "REDIRECT_URIS"
  }
}
```

The client_id and associated client_secret are for the server-side app itself and must be set up as follows in the IdP:

* Access Type: confidential
* Authorization Code Flow: enabled (Keycloak calls this: 'Standard Flow Enabled')
* Resource Owner Password Credentials Grant: enabled (Keycloak calls this 'Direct Access Grants Enabled')

The app knows two scopes for authorisation in the Resource API:

* mpaf-read - Grants read access
* mpaf-write - Grants write access

### OIDC Client

A very rudimentary client to demonstrate the OIDC device code flow is provided. The client currently exclusively 
demonstrates calling the Greeting API v3.

```shell
$ mrmat-python-api-flask-client -h                                                                                    
                      
usage: mrmat-python-api-flask-client [-h] [-q] [-d] [--host HOST] [--port PORT] [--config CONFIG] [--client-id CLIENT_ID] [--client-secret CLIENT_SECRET] [--discovery-url DISCOVERY_URL]

mrmat-python-api-flask-client - 1.0.30

options:
  -h, --help            show this help message and exit
  -q, --quiet           Silent Operation
  -d, --debug           Debug
  --host HOST           Host interface to connect to
  --port PORT           Port to connect to

File Configuration:
  Configure the client via a config file

  --config CONFIG, -c CONFIG
                        Path to the configuration file for the flask client

Manual Configuration:
  Configure the client manually

  --client-id CLIENT_ID
                        The client_id of this CLI itself (not yours!)
  --client-secret CLIENT_SECRET
                        The client_secret of the CLI itself. Not required for AAD, required for Keycloak
  --discovery-url DISCOVERY_URL
                        Discovery of endpoints in the authentication platform
```

You must have an actual user account configured in the IdP so the client can actually log you in. The client itself
requires its own client-id and secret with the following parameters in the IdP:

* Access Type: confidential
* Device Authorization Grant: enabled (Keycloak calls this 'OAuth 2.0 Device Authorization Grant Enabled')

The client can be configured via the CLI parameters on its own, but also supports a configuration file of the
following form. The DISCOVERY_URL must point to the URL where the IdP publishes its well-known endpoints.

```json
{
  "client_id": "CLIENT_ID",
  "client_secret": "CLIENT_SECRET",
  "discovery_url": "DISCOVERY_URL"
}
```

>The client requires configuration with OIDC secrets and currently implements the Device code flow 
